import sqlite3
import subprocess
import time
from datetime import datetime, timedelta
import requests

# rutas
db_path = "packages.db"
log_path = "latest.log"

# ejecución de latest.py como subproceso
def start_latest_script():
    return subprocess.Popen(
        ["python3", "latest.py"], 
        stdout=subprocess.PIPE,
        stderr=subprocess.PIPE,
        text=True, 
        bufsize=1,
        universal_newlines=True
    )

# lectura del archivo de log
def read_latest_log():
    try:
        with open(log_path, "r") as log_file:
            entries = log_file.read().strip().split("\n\n")
        return entries
    except FileNotFoundError:
        print(f"El archivo {log_path} no se encuentra.")
        return []

# lectura de bd
def get_packages_from_db():
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("SELECT name FROM packages")
    packages = [row[0] for row in cursor.fetchall()]
    conn.close()
    return packages

# almacenar paquetes, usado en DEBUG
def store_package(name, version):
    conn = sqlite3.connect(db_path)
    cursor = conn.cursor()
    cursor.execute("CREATE TABLE IF NOT EXISTS packages (name TEXT, version TEXT)")
    cursor.execute("INSERT INTO packages (name, version) VALUES (?, ?)", (name, version))
    conn.commit()
    conn.close()

# envía la notificación por Telegram
def send_message(bot_token, chat_id, message):
    url = f"https://api.telegram.org/bot{bot_token}/sendMessage"
    payload = {
        "chat_id": chat_id,
        "text": message
    }
    try:
        response = requests.post(url, json=payload)
        if response.status_code == 200:
            print("Mensaje enviado exitosamente")
        else:
            print(f"Error al enviar el mensaje: {response.text}")
    except Exception as e:
        print(f"Error al conectar con Telegram: {e}")

# verifica vulnerabilidades y construye la notificación
def check_vulnerabilities(new_entries):
    packages = get_packages_from_db()

    for entry in new_entries:
        if entry.strip() == "":
            continue
        
        lines = entry.split("\n")
        
        description_line = [line for line in lines if line.startswith("Description:")]
        cve_line = [line for line in lines if line.startswith("CVE ID:")]
        if not description_line:
            print(f"Error: No se encontró la línea de descripción en la entrada: {entry}")
            continue
        
        description_start_index = lines.index(description_line[0])
        description = "\n".join(lines[description_start_index:]).replace("Description: ", "").strip()

        cve_start_index = lines.index(cve_line[0])
        detalles = "\n".join(lines[cve_start_index:]).replace("CVE ID: ", "").strip()

        for package_name in packages:
            if package_name in description:
                # añadir token del bot, e id del chat
                bot_token = ""
                chat_id = ""
                message = f"Vulnerabilidad en su sistema en el paquete {package_name}, {detalles}"
                send_message(bot_token, chat_id, message)



def main():

    # DEBUG: Añade un paquete a la bd para comprobar funcionamiento.
    #store_package("Chrome", "1.0")
    
    process = start_latest_script()
    
    print("Proceso latest.py iniciado.")
    
    last_checked = datetime.utcnow()
    initial_entries = read_latest_log()
    
    while True:
        if process.poll() is not None:
            print("El proceso latest.py ha terminado. Reiniciando...")
            process = start_latest_script()

        if datetime.utcnow() - last_checked >= timedelta(minutes=2):
            print("Revisando el archivo latest.log...")
            current_entries = read_latest_log()
            new_entries = [entry for entry in current_entries if entry not in initial_entries]
            if new_entries:
                print(f"Encontradas {len(new_entries)} nuevas entradas en el log.")
                check_vulnerabilities(new_entries)
                initial_entries = current_entries
            last_checked = datetime.utcnow()

        time.sleep(10)

if __name__ == "__main__":
    main()
