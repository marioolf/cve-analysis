import re
import requests
import time
from telethon import TelegramClient, events
from telethon.errors.rpcerrorlist import ChannelPrivateError
import datetime
from bs4 import BeautifulSoup

from qualys_searcher import qualys_checker
from cveorg import check_cve_state

# Configura tus API ID y hash
api_id = ''
api_hash = ''
channel_username = 'https://t.me/cveNotify' #Canal a monitorizar


client = TelegramClient('session_name', api_id, api_hash)

def read_database(filepath):
    entries = []
    with open(filepath, 'r', encoding='latin-1') as file:
        for line in file:
            entry = line.strip().lower()
            if entry:
                entries.append(entry)
    return entries


def save_notification(filepath, message):
    with open(filepath, 'a') as file:
        file.write(f'{datetime.datetime.now()}: {message}\n')


def check_cve_in_nvd(cve_id):
    url = f'https://services.nvd.nist.gov/rest/json/cves/2.0?cveId={cve_id}'
    
    while True:
        response = requests.get(url)
        
        if response.status_code == 200:
            data = response.json()
            if data.get("totalResults", 0) > 0:
                return True
            return False
        else:
            print(f'recibido un : {response.status_code}, esperando 30 segs')
            time.sleep(30)

def check_cve_in_incibe(cve_id):
    url = f'https://www.incibe.es/incibe-cert/alerta-temprana/vulnerabilidades/{cve_id}'
    
    response = requests.get(url)
    
    if response.status_code == 200:
        soup = BeautifulSoup(response.content, 'html.parser')
        div = soup.find('div', class_='date float-right')
        
        if div:
            return div.get_text(strip=True)
        else:
            return "No almacenada"
    else:
        return "No almacenada"


def extract_cve(message):
    pattern = r'CVE-\d{4}-\d{4,7}'
    match = re.search(pattern, message, re.IGNORECASE)
    return match.group(0) if match else None

async def main():
    try:
        entity = await client.get_entity(channel_username)
        print(f'Conectado al canal: {entity.title}')
    except ValueError:
        print(f'No se encontró el canal con el nombre {channel_username}')
        return
    except ChannelPrivateError:
        print(f'No tienes acceso al canal {channel_username}')
        return


    db_entries = read_database('../scrapers_python/packages.db')

    @client.on(events.NewMessage(chats=entity))
    async def handler(event):
        message_text = event.message.text.lower()
        print(f'Nuevo mensaje: {message_text}')

        matches = [entry for entry in db_entries if entry in message_text]
        if matches:
            notification_message = f'Match found: {", ".join(matches)} in message: {message_text}'
            print(notification_message)
            save_notification('notifications.log', notification_message)

        cve_id = extract_cve(message_text).upper()
        if cve_id:
            print(f'Encontrado CVE: {cve_id}')
            print(f'Análisis en Qualys:\n')
            qualys_checker(cve_id)
            cve_exists = check_cve_in_nvd(cve_id)
            if cve_exists:
                save_notification('cve_notifications.log', f'{cve_id} notificado por cveNotify encontrado en NVD.')
            else:
                save_notification('cve_notifications.log', f'WARNING: {cve_id} notificado por cveNotify no encontrado en NVD.')
            
            cve_exists_incibe = check_cve_in_incibe(cve_id)
            save_notification('cve_notifications.log', f'Dicho CVE, {cve_id}, figura como {cve_exists_incibe} en Incibe AT')

            cve_exists_cveorg = check_cve_state(cve_id)
            save_notification('cve_notifications.log', f'Dicho CVE, {cve_id}, figura como {cve_exists_cveorg} en CVE.org')

    print('Escuchando mensajes en el canal...')
    await client.run_until_disconnected()

with client:
    client.loop.run_until_complete(main())
