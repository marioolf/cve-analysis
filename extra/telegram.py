from telethon import TelegramClient, events
from telethon.errors.rpcerrorlist import ChannelPrivateError
import datetime


#añadir id y hash, además del canal a monitorizar
api_id = ''
api_hash = ''
channel_username = ''


client = TelegramClient('session_name', api_id, api_hash)

def read_database(filepath):
    entries = []
    with open(filepath, 'r', encoding='latin-1') as file:
        for line in file:
            entry = line.strip().lower()
            if entry: 
                entries.append(entry)
    return entries


def save_notification(filepath, message):
    with open(filepath, 'a') as file:
        file.write(f'{datetime.datetime.now()}: {message}\n')

async def main():
    try:
        entity = await client.get_entity(channel_username)
        print(f'Conectado al canal: {entity.title}')
    except ValueError:
        print(f'No se encontró el canal con el nombre {channel_username}')
        return
    except ChannelPrivateError:
        print(f'No tienes acceso al canal {channel_username}')
        return


    db_entries = read_database('../scrapers_python/packages.db')


    @client.on(events.NewMessage(chats=entity))
    async def handler(event):
        message_text = event.message.text.lower()
        print(f'Nuevo mensaje: {message_text}')


        matches = [entry for entry in db_entries if entry in message_text]
        if matches:
            notification_message = f'Match found: {", ".join(matches)} in message: {message_text}'
            print(notification_message)
            save_notification('notifications.log', notification_message)

    print('Escuchando mensajes en el canal...')
    await client.run_until_disconnected()

with client:
    client.loop.run_until_complete(main())
